<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è¸©åœ°é›·</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            overflow: hidden; /* Prevent the whole page from scrolling */
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10+ */
            user-select: none;
            -webkit-touch-callout: none; /* iOS Safari */
            overscroll-behavior-y: contain; /* Prevent pull-to-refresh on mobile */
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            background-color: #dcdcdc;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            width: 100vw; /* Full viewport width */
            height: 100vh; /* Full viewport height */
            overflow-y: auto; /* Allow this container to scroll if content overflows */
            box-sizing: border-box;
        }

        #grid-container {
            display: grid;
            grid-template-columns: repeat(20, 30px);
            grid-template-rows: repeat(20, 30px);
            border: 3px solid #333;
            background-color: #c0c0c0;
            margin: 20px 0;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            /* Fix height to prevent collapse: 20 cells * 30px/cell = 600px */
            min-height: 600px;
            min-width: 600px;
        }

        .cell {
            width: 30px;
            height: 30px;
            border: 1px solid #a9a9a9;
            background-color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
            flex-shrink: 0; /* Prevent cells from shrinking */
        }

        .cell.revealed {
            background-color: #fff;
        }

        .cell.revealed.c1 { color: blue; }
        .cell.revealed.c2 { color: green; }
        .cell.revealed.c3 { color: red; }
        .cell.revealed.c4 { color: darkblue; }
        .cell.revealed.c5 { color: brown; }
        .cell.revealed.c6 { color: cyan; }
        .cell.revealed.c7 { color: black; }
        .cell.revealed.c8 { color: grey; }

        #settings {
            margin-bottom: 10px;
        }

        #mode-toggle-container {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .mode-btn, button {
            padding: 12px 20px;
            font-size: 1.5rem; 
            border: 2px solid #888;
            border-radius: 8px;
            background-color: #f0f0f0;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .mode-btn.active {
            background-color: #a5d6a7;
            border-color: #388e3c;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        
        button {
            margin-top: 10px;
        }

        #energy-slot {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .light {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background-color: #7f8c8d;
            transition: background-color 0.3s;
        }

        .light.on {
            background-color: #2ecc71;
        }

        #instructions {
            text-align: left;
            max-width: 600px;
            padding-bottom: 50px; /* Add padding at the bottom */
        }
    </style>
</head>
<body>

<div id="game-container">
    <h1>è¸©åœ°é›·</h1>
    <div id="settings">
        <label for="mine-count">åœ°é›·æ•¸ï¼š</label>
        <input type="number" id="mine-count" value="50">
    </div>
    <div id="mode-toggle-container">
        <button id="dig-mode-btn" class="mode-btn active">â›ï¸ æŒ–é–‹</button>
        <button id="flag-mode-btn" class="mode-btn">ğŸš© æ’æ——</button>
    </div>
    <div id="grid-container"></div>
    <div id="energy-slot">
        <div class="light"></div>
        <div class="light"></div>
        <div class="light"></div>
        <div class="light"></div>
        <div class="light"></div>
    </div>
    <div id="computer-assistant"></div>
    <button onclick="initGame()">é‡æ–°é–‹å§‹</button>
    <div id="instructions">
        <h2>éŠæˆ²èªªæ˜</h2>
        <p><strong>ç›®æ¨™ï¼š</strong>æ‰¾å‡ºæ‰€æœ‰ä¸æ˜¯åœ°é›·çš„æ–¹å¡Šï¼Œä¸è¦å¼•çˆ†ä»»ä½•åœ°é›·ã€‚</p>
        <p><strong>ç©æ³•ï¼š</strong></p>
        <ul>
            <li><strong>é›»è…¦ï¼š</strong>å·¦éµé»æ“ŠæŒ–é–‹ï¼Œå³éµé»æ“Šæ’æ——(ğŸš©)ã€‚</li>
            <li><strong>æ‰‹æ©Ÿï¼š</strong>ä½¿ç”¨ä¸Šæ–¹çš„ â›ï¸/ğŸš© æŒ‰éˆ•åˆ‡æ›æ¨¡å¼ã€‚åœ¨ã€ŒæŒ–é–‹ã€æ¨¡å¼ä¸‹é»æ“Šç‚ºæŒ–é–‹ï¼›åœ¨ã€Œæ’æ——ã€æ¨¡å¼ä¸‹é»æ“Šç‚ºæ’æ——ã€‚</li>
        </ul>
        <p><strong>äº”ç‡ˆçé›»è…¦è¼”åŠ©å™¨ï¼š</strong>æ¯ç•¶ä½ æ­£ç¢ºåœ°æ’ä¸Š5å€‹æ——å­(äº®èµ·5å€‹ç¶ ç‡ˆ)ï¼Œé›»è…¦å°‡æœƒè‡ªå‹•å¹«ä½ æ¨™ç¤ºä¸€å€‹åœ°é›·(ğŸ“)ã€‚</p>
    </div>
</div>

<script>
    const GRID_SIZE = 20;
    let mineCount = 50;
    let grid = [];
    let gameOver = false;
    let correctFlagsForBonus = 0;
    let currentMode = 'dig'; // 'dig' or 'flag'

    const gridContainer = document.getElementById('grid-container');
    const mineCountInput = document.getElementById('mine-count');
    const computerAssistant = document.getElementById('computer-assistant');
    const lights = document.querySelectorAll('.light');
    const digModeBtn = document.getElementById('dig-mode-btn');
    const flagModeBtn = document.getElementById('flag-mode-btn');

    digModeBtn.addEventListener('click', () => setMode('dig'));
    flagModeBtn.addEventListener('click', () => setMode('flag'));

    function setMode(newMode) {
        currentMode = newMode;
        if (newMode === 'dig') {
            digModeBtn.classList.add('active');
            flagModeBtn.classList.remove('active');
        } else {
            digModeBtn.classList.remove('active');
            flagModeBtn.classList.add('active');
        }
    }

    function initGame() {
        mineCount = parseInt(mineCountInput.value);
        gameOver = false;
        correctFlagsForBonus = 0;
        grid = [];
        updateLights();
        setMode('dig');
        computerAssistant.innerHTML = '';
        
        for (let i = 0; i < GRID_SIZE; i++) {
            grid[i] = [];
            for (let j = 0; j < GRID_SIZE; j++) {
                grid[i][j] = {
                    isMine: false,
                    isRevealed: false,
                    isFlagged: false,
                    isComputerFlagged: false,
                    adjacentMines: 0
                };
            }
        }

        let minesPlaced = 0;
        while (minesPlaced < mineCount) {
            const x = Math.floor(Math.random() * GRID_SIZE);
            const y = Math.floor(Math.random() * GRID_SIZE);
            if (!grid[x][y].isMine) {
                grid[x][y].isMine = true;
                minesPlaced++;
            }
        }

        for (let i = 0; i < GRID_SIZE; i++) {
            for (let j = 0; j < GRID_SIZE; j++) {
                if (!grid[i][j].isMine) {
                    let count = 0;
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            const ni = i + dx;
                            const nj = j + dy;
                            if (ni >= 0 && ni < GRID_SIZE && nj >= 0 && nj < GRID_SIZE && grid[ni][nj].isMine) {
                                count++;
                            }
                        }
                    }
                    grid[i][j].adjacentMines = count;
                }
            }
        }
        
        createGridDOM();
        renderGrid();
    }
    
    function createGridDOM() {
        gridContainer.innerHTML = '';
        for (let i = 0; i < GRID_SIZE; i++) {
            for (let j = 0; j < GRID_SIZE; j++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.dataset.x = i;
                cell.dataset.y = j;
                
                cell.addEventListener('click', () => handleCellClick(i, j));
                cell.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    handleCellRightClick(i, j);
                });

                gridContainer.appendChild(cell);
            }
        }
    }

    function renderGrid() {
        for (let i = 0; i < GRID_SIZE; i++) {
            for (let j = 0; j < GRID_SIZE; j++) {
                const cellIndex = i * GRID_SIZE + j;
                const cell = gridContainer.children[cellIndex];
                const cellData = grid[i][j];

                cell.innerHTML = '';
                cell.className = 'cell';
                cell.style.backgroundColor = '';

                if (cellData.isRevealed) {
                    cell.classList.add('revealed');
                    if (cellData.isMine) {
                        cell.innerHTML = 'ğŸ’£';
                    } else if (cellData.adjacentMines > 0) {
                        cell.innerHTML = cellData.adjacentMines;
                        cell.classList.add(`c${cellData.adjacentMines}`);
                    }
                } else {
                     if (gameOver && cellData.isFlagged && !cellData.isMine) {
                        cell.innerHTML = 'âŒ';
                    } else if (cellData.isComputerFlagged) {
                        cell.innerHTML = 'ğŸ“';
                        cell.style.backgroundColor = 'rgba(255, 0, 0, 0.1)';
                    } else if (cellData.isFlagged) {
                        cell.innerHTML = 'ğŸš©';
                    }
                }
            }
        }
    }

    function handleCellClick(x, y) {
        if (currentMode === 'dig') {
            handleCellLeftClick(x, y);
        } else { 
            handleCellRightClick(x, y);
        }
    }

    function handleCellLeftClick(x, y) {
        if (gameOver || grid[x][y].isRevealed || grid[x][y].isFlagged || grid[x][y].isComputerFlagged) {
            return;
        }

        if (grid[x][y].isMine) {
            gameOver = true;
            revealAllMines(); // Reveal all other mines on the board
            renderGrid();     // Re-render the grid to show all the bombs
            alert('éŠæˆ²çµæŸï¼ä½ è¸©åˆ°åœ°é›·äº†ã€‚');
            return;
        }

        revealCell(x, y);
        renderGrid();
        checkWin();
    }
    
    function revealCell(x, y) {
        if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE || grid[x][y].isRevealed || grid[x][y].isFlagged || grid[x][y].isComputerFlagged) {
            return;
        }

        grid[x][y].isRevealed = true;

        if (grid[x][y].adjacentMines === 0) {
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    if (dx === 0 && dy === 0) continue;
                    revealCell(x + dx, y + dy);
                }
            }
        }
    }

    function handleCellRightClick(x, y) {
        if (gameOver || grid[x][y].isRevealed) {
            return;
        }

        grid[x][y].isFlagged = !grid[x][y].isFlagged;

        if (grid[x][y].isFlagged && grid[x][y].isMine) {
            correctFlagsForBonus++;
            updateLights();
            if (correctFlagsForBonus === 5) {
                computerRevealMine();
                correctFlagsForBonus = 0;
                setTimeout(updateLights, 1000);
            }
        } else if (!grid[x][y].isFlagged && grid[x][y].isMine) {
            correctFlagsForBonus = Math.max(0, correctFlagsForBonus - 1);
            updateLights();
        }

        renderGrid();
        checkWin();
    }
    
    function updateLights() {
        lights.forEach((light, index) => {
            if (index < correctFlagsForBonus) {
                light.classList.add('on');
            } else {
                light.classList.remove('on');
            }
        });
    }

    // This function now correctly prepares the data for the final reveal.
    function revealAllMines() {
        for (let i = 0; i < GRID_SIZE; i++) {
            for (let j = 0; j < GRID_SIZE; j++) {
                if (grid[i][j].isMine) {
                    grid[i][j].isRevealed = true;
                }
            }
        }
    }

    function computerRevealMine() {
        let unrevealedMines = [];
        for (let i = 0; i < GRID_SIZE; i++) {
            for (let j = 0; j < GRID_SIZE; j++) {
                if (grid[i][j].isMine && !grid[i][j].isFlagged && !grid[i][j].isComputerFlagged) {
                    unrevealedMines.push({x: i, y: j});
                }
            }
        }

        if (unrevealedMines.length > 0) {
            const randomMine = unrevealedMines[Math.floor(Math.random() * unrevealedMines.length)];
            grid[randomMine.x][randomMine.y].isComputerFlagged = true;
            computerAssistant.innerHTML = `åµæ¸¬åˆ°åœ°é›·ä¿¡è™Ÿï¼Œå·²åœ¨ (${randomMine.x}, ${randomMine.y}) æ¨™ç¤ºä¸€å€‹åœ°é›·ã€‚`;
            renderGrid();
        }
    }

    function checkWin() {
        let revealedCount = 0;
        for (let i = 0; i < GRID_SIZE; i++) {
            for (let j = 0; j < GRID_SIZE; j++) {
                if (grid[i][j].isRevealed) {
                    revealedCount++;
                }
            }
        }

        if (revealedCount === GRID_SIZE * GRID_SIZE - mineCount) {
            gameOver = true;
            renderGrid();
            alert('æ­å–œï¼ä½ è´äº†ï¼');
        }
    }

    initGame();
</script>

</body>
</html>
